# 信号处理

### 应用系统

控制平面 | 数据平面
---|---
由信号处理程序组成|由普通程序构成
监控|处理数据
APP代码中看不到何时被调用|
内核态到用户态转变时被调用|

二者完全异步，通过<font color='red'>全局状态变量</font>交流

### 阻塞和解除阻塞信号

隐式阻塞机制 / 显式阻塞信号(sigprocmask)

#### 进程 task-block

|64bit
---|---
pending|任意一位为1->阻塞
block|控制对应位的信号处理是否屏蔽

pending[i] 位为 1, 说明收到信号， 如果block[i]为0, 进行信号处理，否则信号被屏蔽。

### 信号处理函数编写规则

1. 尽可能简单，数据处理交给数据平面
2. 只调用异步信号安全的函数
   1. 函数可重入: a函数n次被调用且执行区间有交集，执行正确，则a是可重入的。 可重入不能碰全局变量
   2. 不能被信号处理程序打断
3. 保存和恢复errno
4. 如果要访问全局变量，阻塞所有信号处理程序从而保护全局变量
5. 全局变量 volatile
6. 用sig_atomic_t声明标志，从而在多核机器中对内存变量进行原子操作 volatile sig_atomic_t flag;

```c
sigprocmask(...,SIGCHLD,...)
while(!pid) pause(); // 错误， 在while sleep之间子进程结束的话会一直阻塞
```

```c
while(!pid) sleep(1); //正确， sleep是低优先级睡眠， 但是如果在while sleep之间子进程结束的话还会睡1s
```

使用sigsuspend()-> 打包了pause()和屏蔽SIGCHLD信号操作，并且是原子的


# 进程间通信

### 管道

- PIPE 无名管道
- FIFO 有名管道

1. 读端: read到EOF， 读进程 readcount==0, 管道中没有数据
2. 写端: 如果读者不存在， close(fd), SIGPIPE给写者， write(fd) 失败返回

### 消息队列

1. 接受端有消息队列PAsQueue

### 共享内存+信号量

- 进程获得共享内存的方式 
    - shmget
    - mmap: mmap(a.txt) -> 推荐

### Socket

- 优势: 可以构造极度松散耦合的分布式系统


# 进程管理

1. 进程结束后，释放资源，只留PCB，发SIGCHLD给父进程
2. 父进程执行wait回收PCB
3. 父进程如果没有回收PCB， 则由#1进程回收

### 进程回收困境

# 进程组和会话

### 进程组

linux中一个命令行就是一个job
``` shell
ls | sort | more
```
用到3个进程，形成一个进程组， 组内用管道传数据， 利用管道同步

前台进程组执行当前正在运行的前台命令行， 默认不以&结束的命令行是tty正在执行的前台命令

进程组中最早建立的进程是组长， 组长PID是组PID， shell只等待组长结束

### 会话


# 内存管理

1. 虚拟内存
   1. 虚拟地址: 编译链接后确定了
   2. 物理地址: 取决于内核分配
   3. MMU: 地址映射
   4. 物理内存分页， 4k byte/page
   5. APP代码数据在不相邻的page
   6. main->两个page: main函数和栈帧; 就可以运行，剩余由缺页异常装入
2. RAM
   1. 固定区域：内核映像:内核代码+静态结构
   2. 剩余: 内核动态数据；APP代码和数据；磁盘/外设高速缓存
3. page 回收
4. 碎片
5. KMA: Kernal Memory Allocator: 分配动态内存
   1. 内核模块
   2. 进程：1个物理页或者整数个 malloc(1024) => 4096, 3072依旧是free的，由APP管理，提供给后续malloc
   3. 外设缓存： 1个物理页框
6. Linux内存分配：伙伴系统 + <font color='red'>slab分配算法(批发零售)</font>
7. 用户空间管理技术
   1. 基于缺页异常的请求调页
   2. 写时复制(COW)
8. 外设缓存管理技术
   1. 大量使用预读：将文件中包含数据的相邻8个数据块写入内存（4k * 8）
   2. 延迟写：写到高速缓存就结束
   3. 大量写操作，所以针对写操作优化磁盘文件系统，读很少。Linux EXT3:日志文件系统
9. 设备驱动
   1.  GUI:x-windows 可以直接写屏幕外设和显存，拥有IO权限
   2.  其他外设: 不可以直接接触外设，而是用系统调用
   3.  二者有交互协议

# Linux/Unix 内核概述

1. 用户进程
   1. 编写守护进程： tty->空； 输出只能写文件；
   2. 有address space
2. 内核进程（线程）
   1. 没有address space
3. 模式切换
   1. 用户态到核心态原因
      1. 系统调用
      2. 异常
      3. 中断
   2. 可重入子程序
      1. 不访问全局变量
      2. 可以反复调用，不管先前是否return
   3. 可重入内核
      1. 内核控制路径：内核为了处理系统调用或者中断必须执行的指令序列 + 内核线程（有三类：系统调用，中断，线程）
         1. 例如：与read()系统调用项环的一个内核控制路径(多少个系统调用=>多少个内核控制路径)；
         2. 256种中断=> 256个控制路径
         3. 有多少内核线程=>多少内核控制路径
      2. 例如： 1234个系统调用，28个内核线程，共有1234+256+28个路径
      3. 多路径并发：5种原因
      4. 可重入内核是指多条内核控制路径同时运行，系统也不会出错的内核
      5. 如何构造
         1. 写可重入函数
         2. 不可重入函数：用锁；访问共享变量时间长：信号量；访问时间短：自旋锁，不用信号量(sleep/notify时间长，指令多)；
         3. 关中断，保护单CPU变量；多CPU系统中关中断是不够的
         4. 不可剥夺的内核控制路径（影响性能）
            1. 涉及非常容易出错的全局变量，现运行进程不放弃CPU，其他内核也不能跑CPU
            2. 如果放弃了CPU，下次运行前要检查访问过的数据结构值
   4. Deadlock
      1. 破坏循环等待条件：有限内核信号量 + 内核按编号递增顺序请求信号量(用地址排序)
        ```
            if(&信号量1 > &信号量2)
                换指针
            P(信号量1)
            P(信号量2)
        ```