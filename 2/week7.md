# 信号处理

### 应用系统

控制平面 | 数据平面
---|---
由信号处理程序组成|由普通程序构成
监控|处理数据
APP代码中看不到何时被调用|
内核态到用户态转变时被调用|

二者完全异步，通过<font color='red'>全局状态变量</font>交流

### 阻塞和解除阻塞信号

隐式阻塞机制 / 显式阻塞信号(sigprocmask)

#### 进程 task-block

|64bit
---|---
pending|任意一位为1->阻塞
block|控制对应位的信号处理是否屏蔽

pending[i] 位为 1, 说明收到信号， 如果block[i]为0, 进行信号处理，否则信号被屏蔽。

### 信号处理函数编写规则

1. 尽可能简单，数据处理交给数据平面
2. 只调用异步信号安全的函数
   1. 函数可重入: a函数n次被调用且执行区间有交集，执行正确，则a是可重入的。 可重入不能碰全局变量
   2. 不能被信号处理程序打断
3. 保存和恢复errno
4. 如果要访问全局变量，阻塞所有信号处理程序从而保护全局变量
5. 全局变量 volatile
6. 用sig_atomic_t声明标志，从而在多核机器中对内存变量进行原子操作 volatile sig_atomic_t flag;

```c
sigprocmask(...,SIGCHLD,...)
while(!pid) pause(); // 错误， 在while sleep之间子进程结束的话会一直阻塞
```

```c
while(!pid) sleep(1); //正确， sleep是低优先级睡眠， 但是如果在while sleep之间子进程结束的话还会睡1s
```

使用sigsuspend()-> 打包了pause()和屏蔽SIGCHLD信号操作，并且是原子的


# 进程间通信

### 管道

- PIPE 无名管道
- FIFO 有名管道

1. 读端: read到EOF， 读进程 readcount==0, 管道中没有数据
2. 写端: 如果读者不存在， close(fd), SIGPIPE给写者， write(fd) 失败返回

### 消息队列

1. 接受端有消息队列PAsQueue

### 共享内存+信号量

- 进程获得共享内存的方式 
    - shmget
    - mmap: mmap(a.txt) -> 推荐

### Socket

- 优势: 可以构造极度松散耦合的分布式系统


# 进程管理

1. 进程结束后，释放资源，只留PCB，发SIGCHLD给父进程
2. 父进程执行wait回收PCB
3. 父进程如果没有回收PCB， 则由#1进程回收

### 进程回收困境

# 进程组和会话

linux中一个命令行就是一个job
``` shell
ls | sort | more
```
用到3个进程，形成一个进程组， 组内用管道传数据， 利用管道同步

前台进程组执行当前正在运行的前台命令行， 默认不以&结束的命令行是tty正在执行的前台命令
