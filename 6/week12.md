# 中断

1. Linux 不支持实时系统

2. Linux中，只要不是关中断，CPU都会响应中断。

中断发生时，CPU执行APP，此时
1. CS： 0x73(用户代码段)
2. EIP: <3G的值， CPU下一条指令地址，在被中断的现运行程序的代码段中
3. ESP/SS: 现运行进程用户栈栈顶/存放现运行进程栈的段地址
4. etc.
中断发生时，硬件把这些信息压进核心栈栈底

hardirq: 判断是非在中断处理程序中
preempt_count: 中断嵌套层次


irq = n:
n + 0x20 = 中断向量

ISR：
每个外设有一个控制器，包括：状态寄存器，命令寄存器，数据缓存。

数据缓存有数据后，状态寄存器中ready位置1并发送中断信号给CPU, CPU会把数据缓存中的数据读取到内存中， 然后ready变回0。
CPU在收到中断信号后，查表找到对应IRQ上的所有ISR并执行。

不规则工作的外设发生中断的时刻对于CPU来说是一个真.随机数

同一个外设的中断请求，系统是串行处理的。
挂在同一根irq上外设的中断请求也是串行处理的。

外设中断处理流程:
1. CPU写命令寄存器，向外设发送明明
2. 每一个外设一次只能执行一个IO命令
3. 每个IO命令完成，外设会给中断信号，中断处理结束，CPU才可以给出下一个命令

1. 所有外设的中断请求都能被及时响应
2. 对于已经被响应的请求执行时间会因为其他中断的加塞而被延长而且不可控
3. 解决: 与硬件交互的部分关中断(读数据到ram, 改变ready位， 向外设下达命令)，并且尽量用少的代码实现


中断上下半段

以网卡为例:
1. 上半段
   1. 确保ram中收妥网络包
2. 下半段:
   1. 执行TCP/IP协议栈
   2. 处理RAM中的网络包
   3. 把网络包送给因为recv而入睡的APP

Linux 认为，如果没有上半段也没有下半段需要执行，并且不持有内核锁，那么内核就是安全的，现运行进程执行的内核可以被剥夺，分配给CPU给的其他进程；
也就是说Linux中一个APP正在进行系统调用的时候也可以被打断。

DMA:
    外设把信号发送给DMA控制器, DMA把数据从外设读入缓存，然后DMA通知CPU并引发中断。
    CPU不再读取数据，而是进行其他操作，比如计算checksum。

PA进程读取外设数据:

新数据的传输起点: 外设数据缓存
(中断上半段)
中间: 核心态缓存
(中断下半段, wakeup PA进程)
(PA把数据从核心态=>PA数据区)
传输终点: 执行读取文件系统调用的进程数据区


read 系统调用:

1. mmap映射
2. 向磁盘发送读取命令
3. 向DMA控制器发送数据传输命令
4. 执行read进程(PA), sleep():放弃CPU，等待磁盘中断信号
5. 被唤醒后，把数据从核心态=>数据区
6. read系统调用返回, read回到用户态，继续运行用户APP

1. 可剥夺内核: 当中断上下半段全部跑完，中断唤醒的某个进程立即运行，不管CPU正在执行的是应用程序还是系统调用
   1. 运行中断处理程序，临界区，关中断时候不可以被抢占
2. 不可剥夺内核: 接收中断的现运行进程返回用户态之后，才能继续进行



若中断处理程序唤醒了优先级更高的进程(中断嵌套，所有下半段结束后需要进行调度)，或者 现运行进程时间片用完， 系统需要重新调度。

中断全部返回后(现运行进程是PA，多层嵌套中断最后一个执行完成的返回进程):
1. if needReschdule==0(没有唤醒其他进程并且时间片还没有用完) || preemption_count!=0(放弃CPU不安全):
   1. 恢复现场
2. else if preemption_count=0(放弃CPU安全):
   1. schedule函数,放弃CPU
      1. 找到优先级最高的进程PB
      2. switch(PA,PB), PA变为就绪状态
