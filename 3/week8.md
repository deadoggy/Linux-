# 逻辑地址/线性地址/物理地址

### 确定逻辑地址

1. 编译过程中确定
2. 局部变量只有在运行时才知道
3. 确定全局变量逻辑地址
   1. 静态链接过程
      1. imageBegin
      2. 第一次扫描
         1. 确定子程序地址
         2. 确定全局变量地址
         3. 最后代码段只有一个
      3. 第二次扫描
         1. 修改代码段指令，用已知地址取代全局变量符号
         2. 共享库不确定地址用？号
         3. 产生了可执行程序
   2. 动态链接过程
      1. 确定共享库逻辑地址
      2. ld程序：代码段，数据段，BSS
      3. 浪费了虚地址空间，但是物理地址不浪费，因为按需调页
      4. 确定可执行程序运行所需要的一切符号(全局)逻辑地址，之后就可以运行
4. 确定局部变量逻辑地址

### 线性地址

1. 用户空间（可执行程序， ld, 动态链接库）
2. 内核空间（linux内核）
3. 应用程序的段：...
4. BSS:不带初值的全局变量
5. 多个进程执行一个APP：共享代码段和只读变量段
6. 共享库的段：代码/数据/BSS
7. 08048000: main起始地址
8. 地址空间先排共享库再排APP，因为共享库的代码段和数据段程度固定
9. 之后排ld程序
10. 运行时先ld, 再main+共享库
11. ld执行结束后， ld的地址空间就可以删除了，可以被APP的malloc利用了

### 内存寻址

作业1 : 观察虚拟地址空间

1. 逻辑地址
2. 线性地址
3. 物理地址
4. 逻辑 =》 分段单元 =》线性 =》分页单元 =》 物理
5. CS： 段寄存器 [INDEX, TI, RPL]: ti:Table indicator; RPL: Requestot Privilege Level, 00(ring 0) for kernal, 11(ring 3) for user
6. DS:  段选择子 [INDEX, TI, RPL]
7. 分段
   1. GDT:段描述符表(内存中) [Base*, G, Limit*, Type*, DPL*, D/B P]
   2. APP运行访问四个段： 内核代码段[12]CS + 内核数据段[13]DS + 用户代码段[14]CS + 用户数据段[15]DS （堆栈段在数据段内）
   3. CPU核心态： CS=0X60: 0001100|0|00
   4. CPU 会把GDT的表项缓存在CPU中
   5. Linux中 线性等于逻辑， 因为Base是 0 
8. 分页
   1. 32位： 32位地址
   2. 64位： 48位地址
   3. PTE 页表项： 32bit ***
   4. FrameID [FrameID * 4k, (FrameID+1) * 4K)
      1. 在frameid页框中装PA进程的一个逻辑页面，其中指令（变量）的逻辑地址 [ i * 4k, (i+1) * 4k )
      2. R/W = 1, 代码； R/W=0, 数据
      3. U/S = 1, PA是应用程序； U/S = 0, PA是Linux内核
      4. 一个主存页框装 1024个PTE
      5. P = 1, 页面在内存中
      6. 32bit机
         1. 10 + 10 + 12 常规映射
         2. 2 + 9 + 9 + 12 : 2=》CR3/PDPT页目录表 （PAE）
      7. 64bit
         1. 9 + 9 + 9 + 9 + 12 

### 硬件缓存

作业2 512 * 513 513 * 513 转置， 观察时间

1. 